var documenterSearchIndex = {"docs":
[{"location":"#PRONTO.jl","page":"PRONTO.jl","title":"PRONTO.jl","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Hello and welcome to the julia implementation of the PRojection-Operator-Based Newton’s Method for Trajectory Optimization (PRONTO).","category":"page"},{"location":"#An-Example:-Two-Spin-System","page":"PRONTO.jl","title":"An Example: Two Spin System","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We consider the Schrödinger equation","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"idotpsi(t)rangle = (mathcalH_0 + phi(t)mathcalH_1)psi(t)rangle","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where mathcalH_0 = sigma_z = beginbmatrix 0  1 \n1  0 endbmatrix, and mathcalH_1 = sigma_y = beginbmatrix 0  -i \ni  0 endbmatrix are the Pauli matrices. The real control input phi(t) drives the system between 2 qubit states 0rangle and 1rangle, which are the two eigenstates of the free Hamiltonian mathcalH_0. We wish to find the optimal control input phi^star(t) that performs the state-to-state transfer from 0rangle to 1rangle. To do this, we will solve:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"min h(xi) = p(x(T)) + int^T_0 l(x(t)u(t)t) dt \nst    quad dotx = f(xut) x(0) = x_0\ntextwhere quad xi(cdot) = x(cdot)u(cdot)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"First, we load some dependencies:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using PRONTO\nusing StaticArrays, LinearAlgebra","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Note that psi rangle is a 2 times 1 complex vector, and we wish to have the state vector x in the real form. We can define our state vector ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"x = beginbmatrix\nRe(psirangle)\nIm(psirangle) \nendbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"which in this case is a 4 times 1 vector of real numbers. Moreover, any complex square matrix mathcalH can be represented in its real form using the helper function mprod:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"H_re = beginbmatrix\nRe(mathcalH)  -Im(mathcalH) \nIm(mathcalH)  Re(mathcalH)\nendbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function mprod(H) \n    Re = I(2) \n    Im = [0 -1; 1 0] \n    H_re = kron(Re,real(H)) + kron(Im,imag(H)); \n    return H_re \nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We also define a function inprod to compute the real representation of psirangle langle psi using x:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function inprod(x) \n    i = Int(length(x)/2) \n    a = x[1:i] \n    b = x[i+1:end] \n    P = [a*a'+b*b' -(a*b'+b*a'); a*b'+b*a' a*a'+b*b'] \n    return P\nend","category":"page"},{"location":"#Model-Definition","page":"PRONTO.jl","title":"Model Definition","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We decide to name our model Spin2, where {4,1,3} represents the 4 state vector x (psirangle), the single input u (phi) and the 3 parameters kl, kr, kq.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@kwdef struct Spin2 <: PRONTO.Model{4,1,3}\n    kl::Float64 # stage cost gain\n    kr::Float64 # regulator r gain\n    kq::Float64 # regulator q gain\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, the control objective is to steer the system from the 0rangle = 1 0^T state to the target state 1rangle = 0 1^T. We can then define our terminal cost function m(psi(T)) as ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"m(psi(T)) = frac12 langle psi(T)Ppsi(T)rangle = frac12 langle psi(T)(I-1rangle langle 1)psi(T)rangle","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function termcost(x,u,t,θ)\n    P = I(4) - inprod([0 1 0 0])\n    1/2 * collect(x')*P*x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We convert the the Schrödinger equation idotpsi(t)rangle = (mathcalH_0 + phi(t)mathcalH_1)psi(t)rangle into the system dynamics ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"dotx(t) = H(u)x = beginbmatrix\n0  0  1  0 \n0  0  0  -1\n-1  0  0  0\n0  1  0  0\nendbmatrixx + ubeginbmatrix\n0  -1  0  0 \n1  0  0  0\n0  0  0  -1\n0  0  1  0\nendbmatrixx","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function dynamics(x,u,t,θ)\n    H0 = [0 1;1 0]\n    H1 = [0 -im;im 0]\n    return mprod(-im*(H0 + u[1]*H1) )*x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, we only consider the use of energy during the process, and we define our incremental cost","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"int_0^T l(xut) dt = int_0^T frackl2u^Tu quad dt","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"as","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"stagecost(x,u,t,θ) = 1/2 *θ.kl*collect(u')I*u","category":"page"},{"location":"#Regulator","page":"PRONTO.jl","title":"Regulator","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, a Linear-Quadratic Regulator (LQR) is used and designed in this way:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"R_r(t) = I\nQ_r(t) = I - psi(t)rangle langle psi(t)\nP_r(T) = Q_r(T) = I - psi(T)rangle langle psi(T)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"regR(x,u,t,θ) = θ.kr*I(1)\n\nfunction regQ(x,u,t,θ) \n    x_re = x[1:2] \n    x_im = x[3:4] \n    ψ = x_re + im*x_im \n    θ.kq*mprod(I(2) - ψ*ψ')\nend\n\nPRONTO.Pf(α,μ,tf,θ::Spin2) = SMatrix{4,4,Float64}(I(4) - α*α')","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We have finished defining our model! Now it is the time to generate the functions so PRONTO can solve the optimization problem.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"PRONTO.generate_model(Spin2, dynamics, stagecost, termcost, regQ, regR)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"All these functions below are for PRONTO's internal use to solve the problem.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"[PRONTO: generating the TwoSpin model\n    > initializing symbolics...\n    > tracing functions for TwoSpin...\n        > generated f!(out, x, u, t, θ::TwoSpin)\n        > generated Q(x, u, t, θ::TwoSpin)\n        > generated R(x, u, t, θ::TwoSpin)\n        > generated f(x, u, t, θ::TwoSpin)\n        > generated fx(x, u, t, θ::TwoSpin)\n        > generated fu(x, u, t, θ::TwoSpin)\n        > generated l(x, u, t, θ::TwoSpin)\n        > generated lx(x, u, t, θ::TwoSpin)\n        > generated lu(x, u, t, θ::TwoSpin)\n        > generated lxx(x, u, t, θ::TwoSpin)\n        > generated lxu(x, u, t, θ::TwoSpin)\n        > generated luu(x, u, t, θ::TwoSpin)\n        > generated Lxx(λ, x, u, t, θ::TwoSpin)\n        > generated Lxu(λ, x, u, t, θ::TwoSpin)\n        > generated Luu(λ, x, u, t, θ::TwoSpin)\n        > generated p(x, u, t, θ::TwoSpin)\n        > generated px(x, u, t, θ::TwoSpin)\n        > generated pxx(x, u, t, θ::TwoSpin)\n    > done!","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For example, we take a look into fu, which is the first derivative of our dynamics function f ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"dotx=H(u)x = beginbmatrix\n0  0  1  0 \n0  0  0  -1\n-1  0  0  0\n0  1  0  0\nendbmatrixx + ubeginbmatrix\n0  -1  0  0 \n1  0  0  0\n0  0  0  -1\n0  0  1  0\nendbmatrixx","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"with respect to u. Mathematically, fu is","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"beginbmatrix\n0  -1  0  0 \n1  0  0  0\n0  0  0  -1\n0  0  1  0\nendbmatrixx = beginbmatrix\n                    -x_2\n                    x_1\n                    -x_4\n                    x_3\n                 endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"In PRONTO, fu looks like this:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function PRONTO.fu(x, u, t, θ::TwoSpin)\n    out = (MMatrix{4, 1, Float64})(undef)\n    @inbounds begin\n            out[1] = (*)(-1, (getindex)(x, 2))\n            out[2] = (getindex)(x, 1)\n            out[3] = (*)(-1, (getindex)(x, 4))\n            out[4] = (getindex)(x, 3)\n        end\n    return (SMatrix{4, 1, Float64})(out)\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"They are exactly the same! However, PRONTO.jl has generated an efficient implementation for us automatically.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We now show how to solve the problem. The initial state is the 0rangle state x_eig(1), and we will solve the system from time t0=0 to tf=10.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"x0 = SVector{4}(x_eig(1))\nt0,tf = τ = (0,10)","category":"page"},{"location":"#Parameters","page":"PRONTO.jl","title":"Parameters","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"θ = Spin2(kl=0.01, kr=1, kq=1)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"To initialize our solver, we set the initial guess input mu(t) = 05sin(t), and then we obtain the intial trajectory varphi by solving the open loop problem:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"μ = @closure t->SVector{1}(0.5*sin(t))\nφ = open_loop(θ,x0,μ,τ)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Finally, we are ready to solve the optimization problem! ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@time ξ = pronto(θ,x0,φ,τ; tol = 1e-5, maxiters = 50, limitγ = true)","category":"page"},{"location":"#Results","page":"PRONTO.jl","title":"Results","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"If you do this right, you should get: (Image: image description) (Image: image description)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"The top figure is the optimal control input u(t), while the bottom figure is the state vector x(t) evolves in time. We wish to check if we achieve our control objective, which is to steer the system from 0rangle to 1rangle, the evolution in time of population is shown below (Image: image description)   ","category":"page"}]
}
