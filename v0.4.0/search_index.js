var documenterSearchIndex = {"docs":
[{"location":"cheat_sheet/#Cheat-Sheet","page":"Cheat Sheet","title":"Cheat Sheet","text":"","category":"section"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Updated and adapted to match this implementation a bit more. Everything acts under a parameter set θ.","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"PRONTO iterates ξ, φ is the reference trajectory","category":"page"},{"location":"cheat_sheet/#Requirements","page":"Cheat Sheet","title":"Requirements","text":"","category":"section"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Dynamics: $ f(x(t),u(t),t,θ) $","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Stage Cost $ l(x(t),u(t),t,θ) $","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Terminal Cost $ p(x(t),u(t),t,θ) $","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Regulator Matrices $ R(x(t),u(t),t,θ), Q(x(t),u(t),t,θ) $","category":"page"},{"location":"cheat_sheet/#PRONTO","page":"Cheat Sheet","title":"PRONTO","text":"","category":"section"},{"location":"cheat_sheet/#Regulator","page":"Cheat Sheet","title":"Regulator","text":"","category":"section"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"The regulator is computed by:","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"K_r(t) = R_r(t)^-1 B_r(t)^T P_r(t)","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Defined by evaluating along α(t),μ(t):","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"A_r(t) = f_x(α(t)μ(t)tθ)","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"B_r(t) = f_u(α(t)μ(t)tθ)","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"R_r(t) = R(α(t)μ(t)tθ)","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Q_r(t) = Q(α(t)μ(t)tθ)","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Where P_r is found  by solving a differential riccati equation backwards in time from P(α(T)μ(T)T).","category":"page"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"-dotP_r = A_r^T P_r + P_r A_r - K_r^T R_r K_r + Q_r","category":"page"},{"location":"cheat_sheet/#Optimizer","page":"Cheat Sheet","title":"Optimizer","text":"","category":"section"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"K_o(t) = R_o^-1(S_o^T + B^T P)","category":"page"},{"location":"cheat_sheet/#Second-Order","page":"Cheat Sheet","title":"Second Order","text":"","category":"section"},{"location":"cheat_sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Q_o = L_xx = l_xx + sum λ_k f_kxx","category":"page"},{"location":"#PRONTO.jl","page":"PRONTO.jl","title":"PRONTO.jl","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Hello and welcome to the julia implementation of the PRojection-Operator-Based Newton’s Method for Trajectory Optimization (PRONTO).","category":"page"},{"location":"#An-Example:-Two-Spin-System","page":"PRONTO.jl","title":"An Example: Two Spin System","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We consider the Schrödinger equation","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"idotpsi(t)rangle = (mathcalH_0 + phi(t)mathcalH_1)psi(t)rangle","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where mathcalH_0 = sigma_z = beginbmatrix 0  1 \n1  0 endbmatrix, and mathcalH_1 = sigma_y = beginbmatrix 0  -i \ni  0 endbmatrix are the Pauli matrices. The real control input phi(t) drives the system between 2 qubit states 0rangle and 1rangle, which are the two eigenstates of the free Hamiltonian mathcalH_0. We wish to find the optimal control input phi^star(t) that performs the state-to-state transfer from 0rangle to 1rangle. To do this, we will solve:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"min h(xi) = p(x(T)) + int^T_0 l(x(t)u(t)t) dt \nst    quad dotx = f(xut) x(0) = x_0\ntextwhere quad xi(cdot) = x(cdot)u(cdot)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"First, we load some dependencies:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using PRONTO\nusing StaticArrays, LinearAlgebra","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Note that psi rangle is a 2 times 1 complex vector, and we wish to have the state vector x in the real form. We can define our state vector ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"x = beginbmatrix\nRe(psirangle)\nIm(psirangle) \nendbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"which in this case is a 4 times 1 vector of real numbers. Moreover, any complex square matrix mathcalH can be represented in its real form using the helper function mprod:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"H_re = beginbmatrix\nRe(mathcalH)  -Im(mathcalH) \nIm(mathcalH)  Re(mathcalH)\nendbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function mprod(H) \n    Re = I(2) \n    Im = [0 -1; 1 0] \n    H_re = kron(Re,real(H)) + kron(Im,imag(H)); \n    return H_re \nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We also define a function inprod to compute the real representation of psirangle langle psi using x:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function inprod(x) \n    i = Int(length(x)/2) \n    a = x[1:i] \n    b = x[i+1:end] \n    P = [a*a'+b*b' -(a*b'+b*a'); a*b'+b*a' a*a'+b*b'] \n    return P\nend","category":"page"},{"location":"#Model-Definition","page":"PRONTO.jl","title":"Model Definition","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We decide to name our model Spin2, where {4,1,3} represents the 4 state vector x (psirangle), the single input u (phi) and the 3 parameters kl, kr, kq.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@kwdef struct Spin2 <: PRONTO.Model{4,1,3}\n    kl::Float64 # stage cost gain\n    kr::Float64 # regulator r gain\n    kq::Float64 # regulator q gain\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, the control objective is to steer the system from the 0rangle = 1 0^T state to the target state 1rangle = 0 1^T. We can then define our terminal cost function m(psi(T)) as ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"m(psi(T)) = frac12 langle psi(T)Ppsi(T)rangle = frac12 langle psi(T)(I-1rangle langle 1)psi(T)rangle","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function termcost(x,u,t,θ)\n    P = I(4) - inprod([0 1 0 0])\n    1/2 * collect(x')*P*x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We convert the the Schrödinger equation idotpsi(t)rangle = (mathcalH_0 + phi(t)mathcalH_1)psi(t)rangle into the system dynamics ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"dotx(t) = H(u)x = beginbmatrix\n0  0  1  0 \n0  0  0  -1\n-1  0  0  0\n0  1  0  0\nendbmatrixx + ubeginbmatrix\n0  -1  0  0 \n1  0  0  0\n0  0  0  -1\n0  0  1  0\nendbmatrixx","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function dynamics(x,u,t,θ)\n    H0 = [0 1;1 0]\n    H1 = [0 -im;im 0]\n    return mprod(-im*(H0 + u[1]*H1) )*x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, we only consider the use of energy during the process, and we define our incremental cost","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"int_0^T l(xut) dt = int_0^T frackl2u^Tu quad dt","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"as","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"stagecost(x,u,t,θ) = 1/2 *θ.kl*collect(u')I*u","category":"page"},{"location":"#Regulator","page":"PRONTO.jl","title":"Regulator","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, a Linear-Quadratic Regulator (LQR) is used and designed in this way:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"R_r(t) = I\nQ_r(t) = I - psi(t)rangle langle psi(t)\nP_r(T) = Q_r(T) = I - psi(T)rangle langle psi(T)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"regR(x,u,t,θ) = θ.kr*I(1)\n\nfunction regQ(x,u,t,θ) \n    x_re = x[1:2] \n    x_im = x[3:4] \n    ψ = x_re + im*x_im \n    θ.kq*mprod(I(2) - ψ*ψ')\nend\n\nPRONTO.Pf(α,μ,tf,θ::Spin2) = SMatrix{4,4,Float64}(I(4) - α*α')","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We have finished defining our model! Now it is the time to generate the functions so PRONTO can solve the optimization problem.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"PRONTO.generate_model(Spin2, dynamics, stagecost, termcost, regQ, regR)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"All these functions below are for PRONTO's internal use to solve the problem.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"[PRONTO: generating the TwoSpin model\n    > initializing symbolics...\n    > tracing functions for TwoSpin...\n        > generated f!(out, x, u, t, θ::TwoSpin)\n        > generated Q(x, u, t, θ::TwoSpin)\n        > generated R(x, u, t, θ::TwoSpin)\n        > generated f(x, u, t, θ::TwoSpin)\n        > generated fx(x, u, t, θ::TwoSpin)\n        > generated fu(x, u, t, θ::TwoSpin)\n        > generated l(x, u, t, θ::TwoSpin)\n        > generated lx(x, u, t, θ::TwoSpin)\n        > generated lu(x, u, t, θ::TwoSpin)\n        > generated lxx(x, u, t, θ::TwoSpin)\n        > generated lxu(x, u, t, θ::TwoSpin)\n        > generated luu(x, u, t, θ::TwoSpin)\n        > generated Lxx(λ, x, u, t, θ::TwoSpin)\n        > generated Lxu(λ, x, u, t, θ::TwoSpin)\n        > generated Luu(λ, x, u, t, θ::TwoSpin)\n        > generated p(x, u, t, θ::TwoSpin)\n        > generated px(x, u, t, θ::TwoSpin)\n        > generated pxx(x, u, t, θ::TwoSpin)\n    > done!","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For example, we take a look into fu, which is the first derivative of our dynamics function f ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"dotx=H(u)x = beginbmatrix\n0  0  1  0 \n0  0  0  -1\n-1  0  0  0\n0  1  0  0\nendbmatrixx + ubeginbmatrix\n0  -1  0  0 \n1  0  0  0\n0  0  0  -1\n0  0  1  0\nendbmatrixx","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"with respect to u. Mathematically, fu is","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"beginbmatrix\n0  -1  0  0 \n1  0  0  0\n0  0  0  -1\n0  0  1  0\nendbmatrixx = beginbmatrix\n                    -x_2\n                    x_1\n                    -x_4\n                    x_3\n                 endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"In PRONTO, fu looks like this:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function PRONTO.fu(x, u, t, θ::TwoSpin)\n    out = (MMatrix{4, 1, Float64})(undef)\n    @inbounds begin\n            out[1] = (*)(-1, (getindex)(x, 2))\n            out[2] = (getindex)(x, 1)\n            out[3] = (*)(-1, (getindex)(x, 4))\n            out[4] = (getindex)(x, 3)\n        end\n    return (SMatrix{4, 1, Float64})(out)\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"They are exactly the same! However, PRONTO.jl has generated an efficient implementation for us automatically.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We now show how to solve the problem. The initial state is the 0rangle state x_eig(1), and we will solve the system from time t0=0 to tf=10.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"x0 = SVector{4}(x_eig(1))\nt0,tf = τ = (0,10)","category":"page"},{"location":"#Parameters","page":"PRONTO.jl","title":"Parameters","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"θ = Spin2(kl=0.01, kr=1, kq=1)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"To initialize our solver, we set the initial guess input mu(t) = 05sin(t), and then we obtain the intial trajectory varphi by solving the open loop problem:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"μ = @closure t->SVector{1}(0.5*sin(t))\nφ = open_loop(θ,x0,μ,τ)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Finally, we are ready to solve the optimization problem! ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@time ξ = pronto(θ,x0,φ,τ; tol = 1e-5, maxiters = 50, limitγ = true)","category":"page"},{"location":"#Results","page":"PRONTO.jl","title":"Results","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"If you do this right, you should get: (Image: image description) (Image: image description)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"The top figure is the optimal control input u(t), while the bottom figure is the state vector x(t) evolves in time. We wish to check if we achieve our control objective, which is to steer the system from 0rangle to 1rangle, the evolution in time of population is shown below (Image: image description)   ","category":"page"},{"location":"devnotes/#PRONTO-Devnotes","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"","category":"section"},{"location":"devnotes/#.-Model-Definition","page":"PRONTO Devnotes","title":"1. Model Definition","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"The model requires: $ f(θ,t,x,u) $","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"using PRONTO\n\n@model TwoSpin begin\n    NX = 4; NU = 1; NΘ = 0\n\n    f(θ,t,x,u) = ...\nend","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"This defines a type:","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"TwoSpin <: PRONTO.Model{4,1,0}","category":"page"},{"location":"devnotes/#.-Model-Derivation","page":"PRONTO Devnotes","title":"2. Model Derivation","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"Symbolically generate functions for:","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"\nf(θtξ)\n\n\ndefined within the pronto module as\n\njulia\nPRONTOf(Mθtξ)\nPRONTOf(Mbufθtξ)\n\n\ndispatch on M where M  PRONTOModel\n\nMacros do the heavy lifting\n\n\nJacobian defined as\n\nJ_x (f) = beginbmatrix\nfracδf_δx_  cdots  fracδf_δx_\nvdots  ddots  vdots\nfracδf_δx_  cdots  fracδf_δx_\nendbmatrix","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"f_x = J_x(f) f_xu = J_u(J_x(f))","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"f2 = f_2","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"f_x21 = fracδf_2δx_1","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"f_xu213 = fracδfracδf_2δx_1δu_3","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"vdots","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"f[2] = f_2 # NX\nfx[2,1] = df2/dx1 # NX,NX\nfxu[2,1,3] = d(df2/dx1)/du3# NX,NX,NU","category":"page"},{"location":"devnotes/#Hello-Jay","page":"PRONTO Devnotes","title":"Hello Jay","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"Here is a model:","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"\n@model Split begin\n    using LinearAlgebra\n        \n    NX = 22; NU = 1; NΘ = 0\n\n    function mprod(x)\n        Re = I(2)  \n        Im = [0 -1;\n            1 0]   \n        M = kron(Re,real(x)) + kron(Im,imag(x));\n        return M   \n    end\n\n    function inprod(x)\n        a = x[1:Int(NX/2)]\n        b = x[(Int(NX/2)+1):(2*Int(NX/2))]\n        P = [a*a'+b*b' -(a*b'+b*a');\n            a*b'+b*a' a*a'+b*b']\n        return P\n    end\n\n    N = 5\n    n = 2*N+1\n    α = 10\n    ω = 0.5\n\n    H = zeros(n,n)\n    for i = 1:n\n        H[i,i] = 4*(i-N-1)^2\n    end\n    v = -α/4 * ones(n-1)\n\n    H0 = H + Bidiagonal(zeros(n), v, :U) + Bidiagonal(zeros(n), v, :L)\n    H1 = Bidiagonal(zeros(n), -v*1im, :U) + Bidiagonal(zeros(n), v*1im, :L)\n    H2 = Bidiagonal(zeros(n), -v, :U) + Bidiagonal(zeros(n), -v, :L)\n\n    nu = eigvecs(H0)\n\n    nu1 = nu[:,1]\n    nu2 = nu[:,2]\n\n    f(θ,t,x,u) = mprod(-1im*ω*(H0 + sin(u[1])*H1 + (1-cos(u[1]))*H2))*x\n    \n    Ql = zeros(2*n,2*n)\n    Rl = I\n    l(θ,t,x,u) = 1/2*x'*Ql*x + 1/2*u'*Rl*u\n    \n    Rr(θ,t,x,u) = diagm(ones(1))\n    Qr(θ,t,x,u) = diagm(ones(2*n))\n    \n    xf = [nu2;0*nu2]\n    function p(θ,t,x,u)\n        P = I(2*n) - inprod(xf)\n        1/2*x'*P*x\n    end\n\n\nend\n","category":"page"},{"location":"devnotes/#.-Intermediate-Operators","page":"PRONTO Devnotes","title":"3. Intermediate Operators","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"Provide convenience for efficiently defining diffeq's later on. Eg.","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"K_r = R_r^-1 B_r^T P_r","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"Ar(M,θ,t,φ) = (fx!(M,buf,θ,t,φ); return buf)\nKr(M,θ,t,φ,Pr) = Rr(...)\\(Br(...)'Pr(...))","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"warning: yo\nshould these be in-place?\nif so, where should buffers be defined?\nthis behavior would almost be closer to an ode solution","category":"page"},{"location":"devnotes/#.-DiffEQs","page":"PRONTO Devnotes","title":"4. DiffEQs","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"fracdPrdt = -A_r^T P_r - P_r A_r + K_r^T R_r K_r - Q_r","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"define an in-place version using the format of DifferentialEquations.jl","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"dPr_dt(dPr, Pr, (M,θ,φ), t)","category":"page"},{"location":"devnotes/#.-ODE-Solutions","page":"PRONTO Devnotes","title":"5. ODE Solutions","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"uses internal buffer and is wrapped by FunctionWrappers.jl - todo: make thread-safe","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"Pr(t)","category":"page"},{"location":"devnotes/#.-Trajectories","page":"PRONTO Devnotes","title":"6. Trajectories","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"special ODE solutions with pretty plots :)","category":"page"},{"location":"devnotes/#.-Buffered-Operators","page":"PRONTO Devnotes","title":"0. Buffered Operators","text":"","category":"section"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"ODE solutions, trajectories, and intermediate operators all behave the same way:","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"apply function in-place using internal buffer (with clear thread-safety)\nreturn a copy of the internal buffer (can use fancy types, eg. sparse arrays)","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"With some differences:","category":"page"},{"location":"devnotes/","page":"PRONTO Devnotes","title":"PRONTO Devnotes","text":"ODEs/Trajectories render as plots (why not everything?)\nintermediate operators and diffeqs should both have symbolic rendering (maybe a macro facilitates this, eg. @symbolic TwoSpin fx)","category":"page"}]
}
