var documenterSearchIndex = {"docs":
[{"location":"#PRONTO.jl","page":"PRONTO.jl","title":"PRONTO.jl","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Hello! Welcome to the julia implementation of the PRojection-Operator-Based Newton’s Method for Trajectory Optimization (PRONTO). PRONTO is a Newton-based method for solving trajectory optimization problems","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"beginarrayrl\nmindisplaystyle  m(x(T)) + int^T_0 l(x(t)u(t)t) dt  \nmathrmst  dotx = f(xut) qquad x(0) = x_0\nendarray","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where tin0T is the time variable, xinmathbb R^n and uinmathbb R^m are the state and input vectors, x_0inmathbb R^n is the initial condition, fmathbb R^ntimesmathbb R^mtimes0Ttomathbb R^n is the dynamic model, and lmathbb R^ntimesmathbb R^mtimes0Ttomathbb R and mmathbb R^ntomathbb R are the incremental and terminal costs, respectively. The key element of PRONTO is the projection operator, which tranforms any pair of state and input curves alpha(t)mu(t) into a trajectory x(t)u(t) that satisfies dot x = f(xut) and x(0)=x_0. This is achieved by solving the differential equation","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"begincases\ndotx = f(xut) qquad x(0) = x_0\nu=mu-K_r(t)(x-alpha)\nendcases ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where K_r(t) is a time-varying feedback gain used to stabilize the trajectory x(t)u(t) around the state and input curves alpha(t)mu(t). To compute K_r(t), PRONTO.jl solves the Differential Riccati Equation","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"begincases\n-dotP_r = A_eta(t)^top P_r+P_rA_eta(t)-K_r^top R_r(t) K_r + Q_r(t) qquad P(T) = P_T\nK_r=R_r(t)^-1B_eta(t)^top P_r\nendcases ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where A_eta(t)B_eta(t) are the Jacobians of the system dynamics, linearized around alpha(t)mu(t). To use PRONTO, the user must provide suitable regulator matrices Q_r(t)R_r(t). If the user does not provide a terminal condition P_T, PRONTO will generate one by solving the Algebraic Riccati Equation for the linearized system. ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"NOTE: Since K_r(t) plays a vital role in stabilizing the solution estimates, the choice of Q_r(t)R_r(t) and P_T is crucial to the covergence of PRONTO, especially for systems with unstable dynamics.","category":"page"},{"location":"#Double-Integrator","page":"PRONTO.jl","title":"Double Integrator","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Our first example shows how to employ PRONTO.jl in the familiar context of linear time-invariant systems. To this end, consider the well-known optimal control problem","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"beginarrayrl\nmin displaystylefrac12x(T)^2_P + frac12int^T_0 x(t)^2_Q + u(t)^2_R dt 8pt\nmathrmst  dotx = Ax + Bu qquad x(0) = x_0\nendarray","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Clearly, this problem can (and should) be solved using a standard Linear-Quadratic Regulator (LQR). However, this is a PRONTO.jl tutorial, so that's what we'll be using instead. We begin by loading some dependencies","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using PRONTO\nusing Base: @kwdef\n\nusing LinearAlgebra\nusing MatrixEquations\nusing StaticArrays","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"The first two packages (PRONTO and Base: @kwdef) are always required to deploy PRONTO.jl. All other packages are useful for this example, but are not strictly necessary in general.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"To initialize PRONTO, we first need to define our model. Since this example features a double integrator, we name our model DoubleInt and specify that it has a 2 states and 1 control input. We also choose to leave the weight matrices R, Q, and P, as undefined model parameters.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@kwdef struct DoubleInt <: Model{2,1}\n    R::Float64 \n    Q::SMatrix{2,2,Float64}\n    P::SMatrix{2,2,Float64}\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Next, we define the dynamic model of the double integrator","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"f(xut) = beginbmatrix 0  1 0  0 endbmatrixx + beginbmatrix 01 endbmatrixu","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"A = [0 1; 0 0]\nB = [0; 1]\n\n@define_f DoubleInt A*x + B*u[1]","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Here, the matrices A and B are hard-coded into the PRONTO model and cannot be changed without redefining the model from scratch. This is deemed acceptable since we're not interested in changing our system.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Next, we define the incremental and terminal cost of our model","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"beginarrayrl\nl(xut) = displaystylefrac12x^top Qx + frac12u^top Ru8pt\nm(x)=displaystylefrac12x^top Px\nendarray","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_l DoubleInt 1/2*R*u[1]^2 + 1/2*x'*Q*x\n@define_m DoubleInt 1/2*x'*P*x","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Here, the matrices R, Q, and P do not need to be specified: PRONTO already knows that the user will provide them as parameters.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Finally, we need to provide the weight matrices for the projection operator. Since this example is too simple for these matrices to have a noticeable impact, we opt for the simplest choice: R_r(t)=1 and Q_r(t)=I_2.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_Rr DoubleInt I(1)\n@define_Qr DoubleInt I(2)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We are now ready to build our model!","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"resolve_model(DoubleInt)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"This command uses symbolic calculations to determine all the necessary Gradients, Jacobians, and Hessians used by PRONTO. You can track the status in the Terminal, but this step is generally very quick.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"In preparation of solving the optimal control problem, it is now time to define all the model parameters that were not hard-coded into the model. For our purposes, we'll select","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"R=004qquad qquad Q=beginbmatrix 1  00  0 endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"and P equal to the solution to the Algebraic Riccati Equation","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"A^topP + PA - PBR^-1B^topP + Q = 0","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"R = 0.04\nQ = diagm([1.0, 0.0])\nP = arec(A,B,R*I,Q)[1]","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"The problem is ready to be solved! Given the initial condition x_0=20^top and time horizon T=2, we pick a guess input mu=0 to start the solver; the tolerance tol is set to be 10^-6.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"θ = DoubleInt(R, Q, P) \nτ = t0,tf = 0,2\nx0 = @SVector [2,0]\n\nμ = t->[0]\n\nη = open_loop(θ,x0,μ,τ)\n\nξ,data = pronto(θ,x0,η,τ; tol=1e-6);","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We now visualize the solution using GLMakie","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using GLMakie\n\nfig = Figure()\nts = range(t0,tf,length=1001)\nax1 = Axis(fig[1,1], xlabel = \"time\", ylabel = \"position [m]\")\nax2 = Axis(fig[2,1], xlabel = \"time\", ylabel = \"velocity [m/s]\")\nax3 = Axis(fig[3,1], xlabel = \"time\", ylabel = \"acceleration [m/s²]\")\n\nlines!(ax1, ts, [ξ.x(t)[1] for t in ts], color = :blue, linewidth = 2)\nlines!(ax2, ts, [ξ.x(t)[2] for t in ts], color = :green, linewidth = 2)\nlines!(ax3, ts, [ξ.u(t)[1] for t in ts], color = :red, linewidth = 2)\n\ndisplay(fig)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"(Image: image description)","category":"page"},{"location":"#Inverted-Pendulum","page":"PRONTO.jl","title":"Inverted Pendulum","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"This example showcases PRONTO's ability to:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"steer the system to an unstable equilibrium point, \nhandle non-convex cost functions,\nuse the desired target as an initial guess. ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We first load a few dependencies","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using PRONTO\nusing LinearAlgebra\nusing StaticArrays\nusing Base: @kwdef","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"To build our OCP, we decide to name our model InvPend. The {2,1} captures the fact that we have two states, xinmathbb R^2, and one control input, u in mathbb R^1. The parameters of this model are the length of the pendulum L, the gravitional acceleration g, and the control effort penalty ρ. We provide nominal values for each parameter.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@kwdef struct InvPend <: Model{2,1} \n    L::Float64 = 2 \n    g::Float64 = 9.81 \n    ρ::Float64 = 1\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Consider the dynamics of an inverted pendulum","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"f(xut)= beginbmatrixx_2 fracgLsinx_1 - fracuLcosx_1endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where x_1 is the angular position, x_2 is the angular velocity, and u is the horizontal acceleration of the fulcrum.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"To steer the pendulum to the upright position, we define the terminal cost","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"m(x) = 1-cos(x_1)+tfrac12x_2^2","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"This non-convex function is zero if and only if x=2kpi0^top, with kinmathbb Z.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"To limit the control effort during the transient 0T, we define the incremental cost","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"l(x) = tfrac12rho u^2","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where rho0 is an additional parameter of the OCP.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Now we can define the dynamics f(xut), the incremental cost l(xut), and the terminal cost m(x).","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_f InvPend [ \n    x[2], \n    g/L*sin(x[1])-u[1]*cos(x[1])/L,\n    ]\n@define_l InvPend 1/2*ρ*u[1]^2\n@define_m InvPend 1-cos(x[1])+x[2]^2/2","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We must now select the LQR matrices used by the projection operator. Since the linearized system is always controllable, we limit ourselves to choosing Qr and Rr. By doing so, we allow PRONTO to automatically compute the terminal conditions PT by linearizing the dynamics around x(T) and solving the Algebraic Riccati Equation.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_Qr InvPend diagm([10, 1])\n@define_Rr InvPend diagm([1e-3])","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Note that, since the target equilibrium is unstable, we selected a very small input penalty R_r. This ensures that the regulator gain K_r(t) will prioritize the angular position error (which has the highest cost) when updating the solution estimate.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"The last step in the problem definition is to call resolve_model to instantiate PRONTO. Since we're interested in seeing how the solution estimate x(t) changes from one iteration to the next, we also ask PRONTO to output an ascii plot of ξ.x after every iteration.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"resolve_model(InvPend)\nPRONTO.preview(θ::InvPend, ξ) = ξ.x","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We are now ready to solve our OCP! To do so, we load the parameters θ, the time horizon τ, and the inital condition x0. Here, we will be using the default value of all our parameters (defined in InvPend). If we wanted to solve our OCP on Mars, we could instead call θ = InvPend(g=3.71,ρ=10), where we've increased the input penalty to account for the reduced gravity.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"θ = InvPend() \nτ = t0,tf = 0,10\nx0 = @SVector [2π/3;0]","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Next, we need to provide PRONTO with an initial guess. Since we wish to steer the pendulum to the upright position, we use the desired equilibrium as an initial guess. Therefore, our initial state and input estimates are alpha(t)=00^top and u(t)=0, respectively, forall tin0T. Note that this initial guess is not a suitable solution because alpha(0)neq x_0.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"μ = t->[0]\nα = t->[0;0]","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We then call the projection operator to turn our guess α,μ into a trajectory η. This step ensures (among other things) that the error η.x(0)-x0 is within machine tolerance.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"η = closed_loop(θ,x0,α,x,τ)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"It is now time to call PRONTO and solve our OCP to a tolerance of 10^-3","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"ξ,data = pronto(θ,x0,η,τ; tol=1e-3);","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Now, we visualize the solution using GLMakie.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using GLMakie\n\nfig = Figure()\nts = range(t0,tf,length=1001)\nax1 = Axis(fig[1,1], xlabel = \"time [s]\", ylabel = \"angular position [rad]\")\nax2 = Axis(fig[2,1], xlabel = \"time [s]\", ylabel = \"angular velocity [rad/s]\")\nax3 = Axis(fig[3,1], xlabel = \"time [s]\", ylabel = \"control input [m/s^2]\")\n\nlines!(ax1, ts, [ξ.x(t)[1] for t in ts], color = :blue, linewidth = 2)\nlines!(ax2, ts, [ξ.x(t)[2] for t in ts], color = :green, linewidth = 2)\nlines!(ax3, ts, [ξ.u(t)[1] for t in ts], color = :red, linewidth = 2)\n\ndisplay(fig)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"(Image: image description)","category":"page"},{"location":"#Qubit:-State-to-State-Transfer","page":"PRONTO.jl","title":"Qubit: State to State Transfer","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We consider the Schrödinger equation","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"idotpsi(t)rangle = (mathcalH_0 + u(t)mathcalH_1)psi(t)rangle","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where mathcalH_0 = sigma_z = beginbmatrix0  1 1  0endbmatrix, and mathcalH_1 = sigma_y = beginbmatrix0  -i i  0endbmatrix are the Pauli matrices. The real control input u(t) drives the system between 2 qubit states 0rangle and 1rangle, which are the two eigenstates of the free Hamiltonian mathcalH_0. We wish to find the optimal control input u^star(t) that performs the state-to-state transfer from 0rangle to 1rangle. To do this, we will solve:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"min m(x(T)) + int^T_0 l(x(t)u(t)t) dt st quad dotx = f(xut) x(0) = x_0","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"First, we load the usual dependencies:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using PRONTO\nusing LinearAlgebra\nusing StaticArrays\nusing Base: @kwdef","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Note that psi rangle is a 2 times 1 complex vector, and we wish to have the state vector x in the real form. We can define our state vector ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"x = beginbmatrixRe(psirangle)Im(psirangle) endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"which in this case is a 4 times 1 vector of real numbers. Moreover, any complex square matrix mathcalH can be represented in its real form:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"H = beginbmatrixRe(mathcalH)  -Im(mathcalH) Im(mathcalH)  Re(mathcalH)endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We can then convert the the Schrödinger equation idotpsi(t)rangle = (mathcalH_0 + phi(t)mathcalH_1)psi(t)rangle into the nonlinear system ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"dotx(t) = H(u)x = beginbmatrix0  0  1  0 0  0  0  -1-1  0  0  00  1  0  0endbmatrixx + ubeginbmatrix0  -1  0  0 1  0  0  00  0  0  -10  0  1  0endbmatrixx","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We decide to name our model Qubit, where {4,1} represents the 4 state vector x (psirangle), and the single input u (phi). For this example, our parameter is kl, which is a scalar that penalizes the control effort.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@kwdef struct Qubit <: Model{4,1}\n    kl::Float64 = 0.01\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"First, we can define our dynamics f","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_f Qubit begin\n    H0 = [0 0 1 0;0 0 0 -1;-1 0 0 0;0 1 0 0]\n    H1 = [0 -1 0 0;1 0 0 0;0 0 0 -1;0 0 1 0]\n    (H0 + u[1]*H1)*x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For our incremental cost l, we simpy penalize the control effort u","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_l Qubit begin\n    1/2*u'*kl*u\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, the control objective is to steer the system from the initial state 0rangle = 1 0^top to the target state 1rangle = 0 1^top. We can then define our terminal cost function m as ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"m(x(T)) = frac12 x^top(T)Px(T) qquad mathrmwithP=beginbmatrix1  0  0  0 0  0  0  00  0  1  00  0  0  0endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"to penilize both real and imaginal parts for 0rangle.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_m Qubit begin\n    Pl = [1 0 0 0;0 0 0 0;0 0 1 0;0 0 0 0]\n    1/2*x'*Pl*x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, a Linear-Quadratic Regulator (LQR) is used. Note that, since the linearized system is not controllable, we need to provide a value for the terminal cost P_T:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"R_r(t) = I_1Q_r(t) = I_4 P_r(T) = I_4","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_Qr Qubit I(4)\n@define_Rr Qubit I(1)\nPRONTO.Pf(θ::Qubit, αf, μf, tf) = SMatrix{4,4,Float64}(I(4))","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Last we compute the Lagrange dynamics L = l + lambda^topf.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"resolve_model(Qubit)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We now can solve the OCP! This time, we assume our guess input mu(t)=04sint and initialize our solver by computing the open loop system open_loop.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"θ = Qubit() # instantiate a new model\nτ = t0,tf = 0,10 # define time domain\nx0 = @SVector [1.0, 0.0, 0.0, 0.0] # initial state\nxf = @SVector [0.0, 1.0, 0.0, 0.0] # final state\nμ = t->SVector{1}(0.4*sin(t)) # open loop input μ(t)\nη = open_loop(θ, x0, μ, τ) # guess trajectory\nξ,data = pronto(θ, x0, η, τ;tol=1e-4); # optimal trajectory","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We then visualize the solution using GLMakie","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using GLMakie\n\nfig = Figure()\nts = range(t0,tf,length=1001)\nax1 = Axis(fig[1,1], xlabel = \"time\", ylabel = \"quantum state\")\nax2 = Axis(fig[2,1], xlabel = \"time\", ylabel = \"population\")\nax3 = Axis(fig[3,1], xlabel = \"time\", ylabel = \"control input\")\n\nlines!(ax1, ts, [ξ.x(t)[1] for t in ts], linewidth = 2, label = \"Re(ψ1)\")\nlines!(ax1, ts, [ξ.x(t)[2] for t in ts], linewidth = 2, label = \"Re(ψ2)\")\nlines!(ax1, ts, [ξ.x(t)[3] for t in ts], linewidth = 2, label = \"Im(ψ1)\")\nlines!(ax1, ts, [ξ.x(t)[4] for t in ts], linewidth = 2, label = \"Im(ψ2)\")\nfig[1, 2] = Legend(fig, ax1)\nlines!(ax2, ts, [ξ.x(t)[1]^2+ξ.x(t)[3]^2 for t in ts], linewidth = 2, label = \"|0⟩\")\nlines!(ax2, ts, [ξ.x(t)[2]^2+ξ.x(t)[4]^2 for t in ts], linewidth = 2, label = \"|1⟩\")\nfig[2, 2] = Legend(fig, ax2)\nlines!(ax3, ts, [ξ.u(t)[1] for t in ts], linewidth = 2)\n\n\ndisplay(fig)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"(Image: image description)","category":"page"},{"location":"#Qubit:-Pauli-X-Gate","page":"PRONTO.jl","title":"Qubit: Pauli X Gate","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We consider a 3-level fluxionium qubit, whose Hamiltonian can be written as","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"H(u)=H_0 + uH_textdrive = beginbmatrix0  0  0 0  10 00  0  50endbmatrix + ubeginbmatrix0  01  03 01  0  0503  05  0endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where H_0 is the free Hamiltonian, H_textdrive is the control Hamiltonian, and u(t) is the control input. We wish to find the optimal control input u^star(t) that performs the X gate for this qubit, that is, u^star(t) steers 0rangle=100^top to 1rangle=010^top, while simultaneously steers 1rangle to 0rangle. Meanwhile, we wish to aviod the undesirade state, which is the 2rangle state of the system. The optimal control input u^star can be obtained by solving the ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"beginarrayrl\nmin displaystylefrac12psi(T)rangle-psi_T^2 + frac12int^T_0 textkqpsi(t)rangle^2_Q + textklu(t)^2 dt 8pt\nmathrmst  idotpsirangle = 2pi mathcalH psirangle qquad psi(0)rangle = beginbmatrix 0rangle  1rangle endbmatrix\nendarray","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where psirangle = beginbmatrix psi_1ranglepsi_2rangle endbmatrix, mathcalH=I_2 otimes H(u), and psi_Trangle = beginbmatrix 1rangle  0rangle endbmatrix. kl is a scalar penilizing the control effort, kq is a scalar that penilize the undesirade population, and Q=I_2 otimes textdiag(001). However this problem is in the complex form, we need to convert the problem to its real representation.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"First, we load some dependencies:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using PRONTO\nusing LinearAlgebra\nusing StaticArrays\nusing Base: @kwdef","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Besides x = beginbmatrixRe(psirangle)Im(psirangle) endbmatrix that converts a complex quantum state psirangle into a real vector x, we define a helper function mprod converting a complex matrix to its real representation","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"M = beginbmatrixRe(mathcalM)  -Im(mathcalM) Im(mathcalM)  Re(mathcalM)endbmatrix","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"function mprod(x)\n    Re = I(2)\n    Im = [0 -1;\n          1 0]\n    M = kron(Re,real(x)) + kron(Im,imag(x))\n    return M\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We decide to name our model XGate3, where {12,1} represents the 12 states vector x (real representation of two quantum states psi_1rangle and psi_2rangle), and the single input u. For this example, our parameters are kl and kq.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@kwdef struct XGate3 <: PRONTO.Model{12,1}\n    kl::Float64 = 0.01\n    kq::Float64 = 0.5\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Now we can define our dynamics","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"f = 2 pi Hx","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where H=textmprod(-imathcalH).","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_f XGate3 begin\n    E0 = 0.0\n    E1 = 1.0\n    E2 = 5.0\n    H0 = diagm([E0, E1, E2])\n    H00 = kron(I(2),H0)\n    a1 = 0.1\n    a2 = 0.5\n    a3 = 0.3\n    Ω1 = a1 * u[1]\n    Ω2 = a2 * u[1]\n    Ω3 = a3 * u[1]\n    H1 = [0 Ω1 Ω3; Ω1 0 Ω2; Ω3 Ω2 0]\n    H11 = kron(I(2),H1)\n    return 2 * π * mprod(-im * (H00 + H11)) * x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For our incremental cost, we penilize both the control effort u and undesirade state 2rangle","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"l = fractextkl2u^topu + fractextkq2x^topQx","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_l XGate3 begin\n    kl/2*u'*I*u + kq/2*x'*mprod(diagm([0,0,1,0,0,1]))*x\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, the control objective is to steer the system from the 0rangle = 1 0 0^top state to the target state 1rangle = 0 1 0^top, while simultaneously steering 1rangle to 0rangle. We can then define our terminal cost function m as ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"m = frac12(x(T)-x_T)^top(x(T)-x_T)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"where x_T = beginbmatrixRe(psi_Trangle)Im(psi_Trangle) endbmatrix.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_m XGate3 begin\n    ψ1 = [1;0;0]\n    ψ2 = [0;1;0]\n    xf = vec([ψ2;ψ1;0*ψ2;0*ψ1])\n    return 1/2*(x-xf)'*I(12)*(x-xf)\nend","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"For this example, a Linear-Quadratic Regulator (LQR) is used and designed in this way:","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"R_r(t) = IQ_r(t) = I P_r(T) = Q_r(T) = I","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"@define_Qr XGate3 I(12)\n@define_Rr XGate3 I(1)\nPRONTO.Pf(θ::XGate3,α,μ,tf) = SMatrix{12,12,Float64}(I(12))","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Last we compute the Lagrange dynamics L = l + lambda^topf.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"resolve_model(XGate3)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"We now can solve the OCP! This time, we assume our guess input mu(t)=fracpiTe^frac-(t-T2)^2T^2cos(2pi t) and initialize our solver by computing the open loop system.","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"θ = XGate3()\nτ = t0,tf = 0,10\nψ1 = [1;0;0]\nψ2 = [0;1;0]\nx0 = SVector{12}(vec([ψ1;ψ2;0*ψ1;0*ψ2]))\nμ = t->SVector{1}((π/tf)*exp(-(t-tf/2)^2/(tf^2))*cos(2*π*1*t))\nη = open_loop(θ, x0, μ, τ) # guess trajectory\nξ,data = pronto(θ, x0, η, τ;tol=1e-4); # optimal trajectory","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Finally, we visualize the solution using GLMakie. We can see from the result that the same control input steers 0rangle to 1rangle and 1rangle to 0rangle, while 2rangle stays low during the whole process. ","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"using GLMakie\n\nfig = Figure()\nts = range(t0,tf,length=1001)\nax1 = Axis(fig[1,1], xlabel = \"time\", ylabel = \"control input\")\nax2 = Axis(fig[2,1], xlabel = \"time\", ylabel = \"population\")\nax3 = Axis(fig[3,1], xlabel = \"time\", ylabel = \"population\")\n\nlines!(ax1, ts, [ξ.u(t)[1] for t in ts], linewidth = 2)\n\nlines!(ax2, ts, [ξ.x(t)[1]^2+ξ.x(t)[7]^2 for t in ts], linewidth = 2, label = \"|0⟩\")\nlines!(ax2, ts, [ξ.x(t)[2]^2+ξ.x(t)[8]^2 for t in ts], linewidth = 2, label = \"|1⟩\")\nlines!(ax2, ts, [ξ.x(t)[3]^2+ξ.x(t)[9]^2 for t in ts], linewidth = 2, label = \"|2⟩\")\naxislegend(ax2, position = :rc)\n\nlines!(ax3, ts, [ξ.x(t)[4]^2+ξ.x(t)[10]^2 for t in ts], linewidth = 2, label = \"|0⟩\")\nlines!(ax3, ts, [ξ.x(t)[5]^2+ξ.x(t)[11]^2 for t in ts], linewidth = 2, label = \"|1⟩\")\nlines!(ax3, ts, [ξ.x(t)[6]^2+ξ.x(t)[12]^2 for t in ts], linewidth = 2, label = \"|2⟩\")\naxislegend(ax3, position = :rc)\n\ndisplay(fig)","category":"page"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"(Image: image description)","category":"page"},{"location":"#Lane-Change","page":"PRONTO.jl","title":"Lane Change","text":"","category":"section"},{"location":"","page":"PRONTO.jl","title":"PRONTO.jl","text":"Coming soon!","category":"page"}]
}
